>>>>>
Starter POMs
https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter

- empty jar, it purpose is to provide neccessary dependances so you don't need to worry what are all neccessary dempendances snd spares you
  a lot of copy/paste 
- Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop shop for all
  the Spring and related technologies that you need without having to hunt through sample code and copy-paste loads of dependency
  descriptors. For example, if you want to get started using Spring and JPA for database access, include the spring-boot-starter-data-jpa
  dependency in your project.
<<<<<

>>>>>
<parent>

- enables to inherit defaults from Spring Boot

Maven users can inherit from the spring-boot-starter-parent project to obtain sensible defaults.
The parent project provides the following features:
    Java 1.8 as the default compiler level.
    UTF-8 source encoding.
    A Dependency Management section, inherited from the spring-boot-dependencies pom, that manages the versions of common dependencies.
	    This dependency management lets you omit <version> tags for those dependencies when used in your own pom.
    An execution of the repackage goal with a repackage execution id.
    Sensible resource filtering.
    Sensible plugin configuration (exec plugin, Git commit ID, and shade).
    Sensible resource filtering for application.properties and application.yml including profile-specific files (for example,
	    application-dev.properties and application-dev.yml)

Note that, since the application.properties and application.yml files accept Spring style placeholders (${…​}), the Maven filtering is
changed to use @..@ placeholders. (You can override that by setting a Maven property called resource.delimiter.)

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.7.RELEASE</version>
	</parent>

With that setup, you can also override individual dependencies by overriding a property in your own project. For instance, to upgrade to
another Spring Data release train, you would add the following to your pom.xml:

	<properties>
		<spring-data-releasetrain.version>Fowler-SR2</spring-data-releasetrain.version>
	</properties>
<<<<<

>>>>>
actuators

Spring Boot provides several out of the box management services with its actuator module, such as health, audits, beans, and more.

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        curl localhost:8080/actuator/health

<<<<<

>>>>>
Command line runner and Application runner

Command line runner and Application runner are both an interface. They are used to execute code after the Spring Boot application started.
These interface holds run(), which will be call just after SpringBeans and ApplicationContext are created.

When you want to execute some piece of code exactly before the application startup completes, you can use it then. In one of our projects,
we used these to source data from other microservices via service discovery, which was registered in Consul.

You can register as many application/command line runners as you want. You just need to register them as Beans in the application context.
Then, Spring will automatically pick them up.

You can order them as well either by extending interface org.springframework.core.Ordered or via the @Order annotation.

ApplicationRunner wraps the raw application arguments and exposes the ApplicationArguments interface,
which has many convenient methods to get arguments, like getOptionNames() to return all the arguments' names,
getOptionValues() to return the argument value, and raw source arguments with method getSourceArgs().

<<<<<

>>>>>
application properties

Spring Boot application converts the command line properties into Spring Boot Environment properties. Command line properties take precedence
over the other property sources.
		server.port = 9090 - change port number
		spring.application.name = demoservice - change app name

Application properties - External properties
Instead of keeping the properties file under classpath, we can keep the properties in different location or path.
You read them with help of -Dspring.config.location = C:\application.properties

		java -jar "jar file".jar -Dspring.config.location = C:\application.properties

Application properties - Active profile
Spring Boot supports different properties based on the Spring active profile.
Properties are kept in different files
	application.properties
	application-dev.properties
	application-prod.properties
While running the JAR file, we need to specify the spring active profile based on each properties file.
		java -jar "jar file".jar -spring.properites.active="dev or prod"

Spring Boot supports YAML based properties configurations to run the application. Instead of application.properties,
we can use application.yml file. This YAML file also should be kept inside the classpath.
We can keep the Spring active profile properties in the single application.yml file.
No need to use the separate file like application.properties.

If the server.port number is 0 while starting the Spring Boot application, Tomcat uses the random port number.

<<<<<

>>>>>
Logging

Spring Boot uses Apache Commons logging for all internal logging. Spring Boot’s default configurations provides a support for the use
of Java Util Logging, Log4j2, and Logback. Using these, we can configure the console logging as well as file logging.

The default log messages will print to the console window. By default, “INFO”, “ERROR” and “WARN” log messages will print in the log file.
If you have to enable the debug level log, add the debug flag on starting your application:
		java –jar demo.jar --debug
or add the debug mode to your application.properties file:
		debug = true

If you want to print the logs in a file, you need to set the property logging.file or logging.path in the application.properties file.
You can specify the log file path using the property. Note that the log file name is spring.log:
		logging.path = /var/tmp/
or You can specify the own log file name:
		logging.file = /var/tmp/mylog.log
Note − files will rotate automatically after reaching the size 10 MB.

Spring Boot supports all logger levels such as “TRACE”, “DEBUG”, “INFO”, “WARN”, “ERROR”, “FATAL”, “OFF”. You can define Root logger
in the application.properties file:
		logging.level.root = WARN

Logback ( successor of Log4j) supports XML based configuration to handle Spring Boot Log configurations. Logging configuration details
are configured in logback.xml file. The logback.xml file should be placed under the classpath.
You can configure the console appender or/and file appender in Logback.xml file. You can define the Log pattern as well
<<<<<

>>>>>
Restfull web service

@RestController - start point, maps JSON, XLM responses
@RequestMapping(value = "/products")
public ResponseEntity<Object> createProduct(@RequestBody Product product){...}
public ResponseEntity<Object> updateProduct(@PathVariable("id") String id){...}
public ResponseEntity<Object> getProduct(@RequestParam(value = "name", required = false, defaultValue = "honey") String name) {...}

The default HTTP request method is GET. This method does not require any Request Body. You can send request parameters and path variables
to define the custom or dynamic URL.
The HTTP POST request is used to create a resource. This method contains the Request Body. We can send request parameters and path variables
to define the custom or dynamic URL.
The HTTP PUT request is used to update the existing resource. This method contains a Request Body. We can send request parameters and
path variables to define the custom or dynamic URL.
The HTTP Delete request is used to delete the existing resource. This method does not contain any Request Body. We can send request
parameters and path variables to define the custom or dynamic URL.
<<<<<

>>>>>
Exception handling

@ControlerAdvice annotated class is a central place to define exception handling, and @ExceptionHandler annotated method in this calss
handles the specific exception and sending the custom responses to the client
<<<<<

>>>>>
Interceptors

You can use the Interceptor in Spring Boot to perform operations under the following situations:
    - Before sending the request to the controller
    - Before sending the response to the client
For example, you can use an interceptor to add the request header before sending the request to the controller and add the response header
before sending the response to the client.

To work with interceptor, you need to create @Component class that supports it and it should implement the HandlerInterceptor interface.
	- preHandle() - perform operations before sending the request to the controller.
	- postHandle() -  perform operations before sending the response to the client.
	- afterCompletion() - perform operations after completing the request and response.

You will have to register this Interceptor with InterceptorRegistry by using @Component WebMvcConfigurerAdapter
<<<<<

>>>>>
Servlet filters

A filter is an object used to intercept the HTTP requests and responses of your application. By using filter,
we can perform two operations at two instances:
    - Before sending the request to the controller
    - Before sending a response to the client

To implement Filter you need @Component that implements Filter interface.
<<<<<

>>>>>
File handling, upload/download

For uploading a file, you can use MultipartFile as a Request Parameter and this API should consume Multi-Part form data value

For file download, you should use InputStreamResource for downloading a File. We need to set the HttpHeader Content-Disposition
in Response and need to specify the response Media Type of the application.
>>>>>
Service Components are the class file which contains @Service annotation. These class files are used to write business logic in a different
layer, separated from @RestController class file.

<<<<<

Spring annotations:
  - @AutoConfigureMockMvc - sets up MockMvc from Spring Test which  allows, via a set of convenient builder classes, to send HTTP requests
    into the DispatcherServlet and make assertions about the result
  - @LocalServerPort - add local server port discovered at runtime
  - @SpringBootTest - whole application context to be created. An alternative would be to ask Spring Boot to create only the web layers
    of the context using the @WebMvcTest
  - @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) - start up embedded server on random port
  - @WebMvcTest - create only the web layers of the context


 curl -X PUT -d '<?xml version="1.0" encoding="UTF-8"?><project><name>G1</name></project>' --header 'Content-Type:application/xml' \
     https://lmr-g1-ci-infobank.rnd.ki.sw.ericsson.se/infobank/rest/project