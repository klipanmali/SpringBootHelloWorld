>>>>>
Starter POMs
https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter

- empty jar, it purpose is to provide neccessary dependances so you don't need to worry what are all neccessary dempendances snd spares you
  a lot of copy/paste 
- Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop shop for all
  the Spring and related technologies that you need without having to hunt through sample code and copy-paste loads of dependency
  descriptors. For example, if you want to get started using Spring and JPA for database access, include the spring-boot-starter-data-jpa
  dependency in your project.
<<<<<

>>>>>
<parent>

- enables to inherit defaults from Spring Boot

Maven users can inherit from the spring-boot-starter-parent project to obtain sensible defaults.
The parent project provides the following features:
    Java 1.8 as the default compiler level.
    UTF-8 source encoding.
    A Dependency Management section, inherited from the spring-boot-dependencies pom, that manages the versions of common dependencies.
	    This dependency management lets you omit <version> tags for those dependencies when used in your own pom.
    An execution of the repackage goal with a repackage execution id.
    Sensible resource filtering.
    Sensible plugin configuration (exec plugin, Git commit ID, and shade).
    Sensible resource filtering for application.properties and application.yml including profile-specific files (for example,
	    application-dev.properties and application-dev.yml)

Note that, since the application.properties and application.yml files accept Spring style placeholders (${…​}), the Maven filtering is
changed to use @..@ placeholders. (You can override that by setting a Maven property called resource.delimiter.)

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.7.RELEASE</version>
	</parent>

With that setup, you can also override individual dependencies by overriding a property in your own project. For instance, to upgrade to
another Spring Data release train, you would add the following to your pom.xml:

	<properties>
		<spring-data-releasetrain.version>Fowler-SR2</spring-data-releasetrain.version>
	</properties>
<<<<<

>>>>>
actuators

Spring Boot provides several out of the box management services with its actuator module, such as health, audits, beans, and more.

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        curl localhost:8080/actuator/health

<<<<<

>>>>>
Command line runner and Application runner

Command line runner and Application runner are both an interface. They are used to execute code after the Spring Boot application started.
These interface holds run(), which will be call just after SpringBeans and ApplicationContext are created.

When you want to execute some piece of code exactly before the application startup completes, you can use it then. In one of our projects,
we used these to source data from other microservices via service discovery, which was registered in Consul.

You can register as many application/command line runners as you want. You just need to register them as Beans in the application context.
Then, Spring will automatically pick them up.

You can order them as well either by extending interface org.springframework.core.Ordered or via the @Order annotation.

ApplicationRunner wraps the raw application arguments and exposes the ApplicationArguments interface,
which has many convenient methods to get arguments, like getOptionNames() to return all the arguments' names,
getOptionValues() to return the argument value, and raw source arguments with method getSourceArgs().

<<<<<

>>>>>
application.properties

Spring Boot application converts the command line properties into Spring Boot Environment properties. Command line properties take precedence
over the other property sources.

server.port = 9090 - change port number
spring.application.name = demoservice - change app name

Application properties - External properties
Instead of keeping the properties file under classpath, we can keep the properties in different location or path.
You read them with help of -Dspring.config.location = C:\application.properties

java -jar "jar file".jar -Dspring.config.location = C:\application.properties

Application properties - Active profile
Spring Boot supports different properties based on the Spring active profile.
Properties are kept in different files
	application.properties
	application-dev.properties
	application-prod.properties
While running the JAR file, we need to specify the spring active profile based on each properties file.
java -jar "jar file".jar -spring.properites.active="dev or prod"
<<<<<

Spring annotations:
  - @AutoConfigureMockMvc - sets up MockMvc from Spring Test which  allows, via a set of convenient builder classes, to send HTTP requests
    into the DispatcherServlet and make assertions about the result
  - @LocalServerPort - add local server port discovered at runtime
  - @SpringBootTest - whole application context to be created. An alternative would be to ask Spring Boot to create only the web layers
    of the context using the @WebMvcTest
  - @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) - start up embedded server on random port
  - @WebMvcTest - create only the web layers of the context
